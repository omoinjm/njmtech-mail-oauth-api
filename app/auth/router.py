from fastapi import APIRouter, Depends, HTTPException, Request
from fastapi.responses import RedirectResponse
from sqlalchemy.ext.asyncio import AsyncSession

# Import base OAuth classes and provider-specific client getters.
from app.auth.base import (
    BaseOAuth2,
    get_google_oauth_client,
    get_microsoft_oauth_client,
)
# Import Pydantic schemas for authentication responses and data transfer.
from app.auth.schemas import AuthResponse, TokenData, UserInfo
# Import database dependency.
from app.core.database import get_db
# Import the repository for user mail account operations.
from app.repositories.user_mail_account import UserMailAccountRepository
# Import the Provider enum for distinguishing OAuth providers.
from app.models.enums import Provider

# Initialize an API router specifically for authentication routes.
# All routes defined in this router will be prefixed with "/auth" and tagged for documentation.
router = APIRouter(prefix="/auth", tags=["Authentication"])

# A dictionary mapping provider names (strings) to their respective OAuth client getters
# and the corresponding Provider enum value. This allows for dynamic selection of OAuth clients.
PROVIDER_MAP = {
    "google": {
        "client": get_google_oauth_client,  # Function to get the Google OAuth client instance
        "provider_enum": Provider.GOOGLE,     # Enum value for Google provider
    },
    "microsoft": {
        "client": get_microsoft_oauth_client, # Function to get the Microsoft OAuth client instance
        "provider_enum": Provider.MICROSOFT,  # Enum value for Microsoft provider
    },
}


# Defines the login endpoint for a given OAuth provider.
# When a user navigates to /auth/{provider}/login, they are redirected to the OAuth provider's
# authorization page.
@router.get("/{provider}/login")
async def login(provider: str, request: Request):
    # Check if the requested provider is supported.
    if provider not in PROVIDER_MAP:
        raise HTTPException(status_code=404, detail="Provider not found")

    # Get the appropriate OAuth client based on the provider.
    oauth_client: BaseOAuth2 = PROVIDER_MAP[provider]["client"]()
    # Generate the authorization URL for the OAuth provider.
    login_url = oauth_client.get_login_url(request)
    # Redirect the user to the provider's login URL.
    return RedirectResponse(login_url)


# Defines the callback endpoint for a given OAuth provider.
# After a user authorizes the application on the OAuth provider's side, they are redirected
# back to this endpoint with authorization `code` and `state` parameters.
@router.get("/{provider}/callback")
async def callback(
    provider: str,
    request: Request,
    code: str,
    state: str,
    db: AsyncSession = Depends(get_db), # Inject an asynchronous database session.
) -> AuthResponse:
    # Check if the requested provider is supported.
    if provider not in PROVIDER_MAP:
        raise HTTPException(status_code=404, detail="Provider not found")

    # Validate the 'state' parameter to prevent CSRF attacks.
    # The 'state' parameter is generated by the client and sent to the OAuth provider,
    # then returned to the callback. It must match the original state stored in the session.
    if "state" not in request.session or request.session["state"] != state:
        raise HTTPException(status_code=400, detail="Invalid state parameter")

    # Remove the state from the session after successful validation to prevent reuse.
    del request.session["state"]

    try:
        # Get the appropriate OAuth client based on the provider.
        oauth_client: BaseOAuth2 = PROVIDER_MAP[provider]["client"]()
        # Exchange the authorization code for access and refresh tokens.
        token_payload = await oauth_client.exchange_code_for_tokens(code)

        # Extract token details from the payload.
        access_token = token_payload.get("access_token")
        refresh_token = token_payload.get("refresh_token")
        expires_in = token_payload.get("expires_in")

        # Validate that essential token information is present.
        if not access_token or not expires_in:
            raise HTTPException(
                status_code=400, detail=f"Invalid token data from {provider}"
            )

        # Use the access token to fetch user information from the OAuth provider.
        user_info_payload = await oauth_client.get_user_info(access_token)

        # Extract the user's email based on the provider.
        email = None
        if provider == "google":
            email = user_info_payload.get("email")
        elif provider == "microsoft":
            email = user_info_payload.get("mail") or user_info_payload.get(
                "userPrincipalName"
            )

        # Validate that the user's email was successfully retrieved.
        if not email:
            raise HTTPException(
                status_code=400, detail=f"Could not retrieve user email from {provider}"
            )

        # Create Pydantic models for user information and token data.
        user_info = UserInfo(email=email)
        token_data = TokenData(
            access_token=access_token,
            refresh_token=refresh_token,
            expires_at=expires_in, # Note: `expires_at` here is actually `expires_in` seconds
        )

        # Initialize the UserMailAccountRepository to interact with the database.
        repo = UserMailAccountRepository(db)
        # Create or update the user's mail account in the database with the new token information.
        await repo.create_or_update_user_with_token(
            user_info, token_data, PROVIDER_MAP[provider]["provider_enum"].value
        )

        # Return the authentication response containing user info and token data.
        return AuthResponse(user=user_info, token=token_data)

    # Catch specific HTTP exceptions and re-raise them.
    except HTTPException as e:
        raise e
    # Catch any other unexpected exceptions and return a generic 500 error.
    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"An unexpected error occurred during {provider} OAuth callback: {e}",
        )